"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[614],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),u=r,h=c["".concat(o,".").concat(u)]||c[u]||m[u]||i;return n?a.createElement(h,s(s({ref:t},d),{},{components:n})):a.createElement(h,s({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[c]="string"==typeof e?e:r,s[1]=l;for(var p=2;p<i;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4593:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:9},s="5.9 Example: Running SSR in WasmEdge",l={unversionedId:"develop/javascript/ssr",id:"develop/javascript/ssr",title:"5.9 Example: Running SSR in WasmEdge",description:'React is very popular JavaScript web UI framework. A React application is "compiled" into an HTML and JavaScript static web site. The web UI is rendered through the generated JavaScript code. However, it is often too slow and resource consuming to execute the complex generated JavaScript entirely in the browser to build the interactive HTML DOM objects. React Server Side Rendering (SSR) delegates the JavaScript UI rendering to a server, and have the server stream rendered HTML DOM objects to the browser. The WasmEdge JavaScript runtime provides a lightweight and high performance container to run React SSR functions on edge servers.',source:"@site/docs/develop/javascript/ssr.md",sourceDirName:"develop/javascript",slug:"/develop/javascript/ssr",permalink:"/book/develop/javascript/ssr",draft:!1,editUrl:"https://github.com/alabulei1/book/docs/develop/javascript/ssr.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"developSidebar",previous:{title:"5.8 Native JS API in Rust",permalink:"/book/develop/javascript/rust"},next:{title:"Develop Wasm Apps in C/C++",permalink:"/book/category/develop-wasm-apps-in-cc"}},o={},p=[{value:"Getting started",id:"getting-started",level:2},{value:"A full React 18 app",id:"a-full-react-18-app",level:2},{value:"Appendix the create-react-app template",id:"appendix-the-create-react-app-template",level:2},{value:"Step 1 \u2014 Create the React App",id:"step-1--create-the-react-app",level:3},{value:"Step 2 \u2014 Create an WasmEdge QuickJS Server and Render the App Component",id:"step-2--create-an-wasmedge-quickjs-server-and-render-the-app-component",level:3},{value:"Step 3 \u2014 Build and deploy",id:"step-3--build-and-deploy",level:3},{value:"Step 4 (alternative) -- build and deploy with rollup.js",id:"step-4-alternative----build-and-deploy-with-rollupjs",level:3}],d={toc:p};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"59-example-running-ssr-in-wasmedge"},"5.9 Example: Running SSR in WasmEdge"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://reactjs.org/"},"React"),' is very popular JavaScript web UI framework. A React application is "compiled" into an HTML and JavaScript static web site. The web UI is rendered through the generated JavaScript code. However, it is often too slow and resource consuming to execute the complex generated JavaScript entirely in the browser to build the interactive HTML DOM objects. ',(0,r.kt)("a",{parentName:"p",href:"https://medium.com/jspoint/a-beginners-guide-to-react-server-side-rendering-ssr-bf3853841d55"},"React Server Side Rendering (SSR)")," delegates the JavaScript UI rendering to a server, and have the server stream rendered HTML DOM objects to the browser. The WasmEdge JavaScript runtime provides a lightweight and high performance container to run React SSR functions on edge servers."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Server-side rendering (SSR) is a popular technique for rendering a client-side single page application (SPA) on the server and then sending a fully rendered page to the client. This allows for dynamic components to be served as static HTML markup. This approach can be useful for search engine optimization (SEO) when indexing does not handle JavaScript properly. It may also be beneficial in situations where downloading a large JavaScript bundle is impaired by a slow network. -- ",(0,r.kt)("a",{parentName:"p",href:"https://www.digitalocean.com/community/tutorials/react-server-side-rendering"},"from Digital Ocean"),".")),(0,r.kt)("p",null,"In this article, we will show you how to use the WasmEdge QuickJS runtime to implement a React SSR function.\nCompared with the Docker + Linux + nodejs + v8 approach, WasmEdge is safer (suitable for multi-tenancy environments) and much lighter (1% of the footprint) with similar performance."),(0,r.kt)("p",null,"We will start from a complete tutorial to create and deploy a simple React Streaming SSR web application, and then move on to a full React 18 demo."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#getting-started"},"Getting started with React streaming SSR")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#a-full-react-18-app"},"A full React 18 app")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#appendix-the-create-react-app-template"},"Appendix: the create-react-app template"))),(0,r.kt)("h2",{id:"getting-started"},"Getting started"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr_stream"},"example_js/react_ssr_stream")," folder in the GitHub repo contains the example's source code. It showcases how to streaming render an HTML string from templates in a JavaScript app running in WasmEdge."),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyHome.jsx"},"component/LazyHome.jsx"),' file is the main page template in React. It "lazy" loads the inner page template after a 2s delay once the outer HTML is rendered and returned to the user.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import React, { Suspense } from 'react';\nimport * as LazyPage from './LazyPage.jsx';\n\nasync function sleep(ms) {\n  return new Promise((r, _) => {\n    setTimeout(() => r(), ms)\n  });\n}\n\nasync function loadLazyPage() {\n  await sleep(2000);\n  return LazyPage\n}\n\nclass LazyHome extends React.Component {\n  render() {\n    let LazyPage1 = React.lazy(() => loadLazyPage());\n    return (\n      <html lang=\"en\">\n        <head>\n          <meta charSet=\"utf-8\" />\n          <title>Title</title>\n        </head>\n        <body>\n          <div>\n            <div> This is LazyHome </div>\n            <Suspense fallback={<div> loading... </div>}>\n              <LazyPage1 />\n            </Suspense>\n          </div>\n        </body>\n      </html>\n    );\n  }\n}\n\nexport default LazyHome;\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyPage.jsx"},"LazyPage.jsx")," is the inner page template. It is rendered 2s after the outer page is already returned to the user."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import React from 'react';\n\nclass LazyPage extends React.Component {\n  render() {\n    return (\n      <div>\n        <div>\n          This is lazy page\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default LazyPage;\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/main.mjs"},"main.mjs"),"\nfile starts a non-blocking HTTP server using standard Node.js APIs, and then renders the HTML page in multiple chuncks to the response."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import * as React from 'react';\nimport { renderToPipeableStream } from 'react-dom/server';\nimport { createServer } from 'http';\n\nimport LazyHome from './component/LazyHome.jsx';\n\ncreateServer((req, res) => {\n  res.setHeader('Content-type', 'text/html; charset=utf-8');\n  renderToPipeableStream(<LazyHome />).pipe(res);\n}).listen(8001, () => {\n  print('listen 8001...');\n})\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/rollup.config.js"},"rollup.config.js")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/package.json"},"package.json")," files are to build the React SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the ",(0,r.kt)("inlineCode",{parentName:"p"},"npm")," command to build it.\nThe output is in the ",(0,r.kt)("inlineCode",{parentName:"p"},"dist/main.mjs")," file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install\nnpm run build\n")),(0,r.kt)("p",null,"Copy over the system's ",(0,r.kt)("inlineCode",{parentName:"p"},"modules")," to the working directory for Node.js API support as ",(0,r.kt)("a",{parentName:"p",href:"nodejs"},"noted here"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cp -r ../../modules .\n")),(0,r.kt)("p",null,"To run the example, do the following on the CLI to start the server."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"nohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &\n")),(0,r.kt)("p",null,"Send the server a HTTP request via ",(0,r.kt)("inlineCode",{parentName:"p"},"curl")," or the browser."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"curl http://localhost:8001\n")),(0,r.kt)("p",null,"The results are as follows. The service first returns an HTML page with an empty inner section (i.e., the ",(0,r.kt)("inlineCode",{parentName:"p"},"loading")," section), and then 2s later, the HTML content for the inner section and the JavaScript to display it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n100   211    0   211    0     0   1029      0 --:--:-- --:--:-- --:--:--  1024\n100   275    0   275    0     0    221      0 --:--:--  0:00:01 --:--:--   220\n100   547    0   547    0     0    245      0 --:--:--  0:00:02 --:--:--   245\n100  1020    0  1020    0     0    413      0 --:--:--  0:00:02 --:--:--   413\n\n<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Title</title></head><body><div><div> This is LazyHome </div>\x3c!--$?--\x3e<template id="B:0"></template><div> loading... </div>\x3c!--/$--\x3e</div></body></html><div hidden id="S:0"><template id="P:1"></template></div><div hidden id="S:1"><div><div>This is lazy page</div></div></div><script>function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("S:1","P:1")<\/script><script>function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("B:0","S:0")<\/script>\n')),(0,r.kt)("h2",{id:"a-full-react-18-app"},"A full React 18 app"),(0,r.kt)("p",null,"In this section, we will demonstrate a complete React 18 SSR application. It renders the web UI through streaming SSR. The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr"},"example_js/react18_ssr")," folder in the GitHub repo contains the example's source code. The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/component"},"component")," folder contains the entire React 18 application's source code, and the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/public"},"public")," folder contains the public resources (CSS and images) for the web application. The application also demonstrates a data provider for the UI."),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/main.mjs"},"main.mjs"),"\nfile starts a non-blocking HTTP server, fetches data from a data provider, maps the ",(0,r.kt)("inlineCode",{parentName:"p"},"main.css")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"main.js")," files in the ",(0,r.kt)("inlineCode",{parentName:"p"},"public")," folder to web URLs, and then renders the HTML page for each request in ",(0,r.kt)("inlineCode",{parentName:"p"},"renderToPipeableStream()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import * as React from 'react';\nimport { renderToPipeableStream } from 'react-dom/server';\nimport { createServer } from 'http';\nimport * as std from 'std';\n\nimport App from './component/App.js';\nimport { DataProvider } from './component/data.js'\n\nlet assets = {\n  'main.js': '/main.js',\n  'main.css': '/main.css',\n};\n\nconst css = std.loadFile('./public/main.css')\n\nfunction createServerData() {\n  let done = false;\n  let promise = null;\n  return {\n    read() {\n      if (done) {\n        return;\n      }\n      if (promise) {\n        throw promise;\n      }\n      promise = new Promise(resolve => {\n        setTimeout(() => {\n          done = true;\n          promise = null;\n          resolve();\n        }, 2000);\n      });\n      throw promise;\n    },\n  };\n}\n\ncreateServer((req, res) => {\n  print(req.url)\n  if (req.url == '/main.css') {\n    res.setHeader('Content-Type', 'text/css; charset=utf-8')\n    res.end(css)\n  } else if (req.url == '/favicon.ico') {\n    res.end()\n  } else {\n    res.setHeader('Content-type', 'text/html');\n\n    res.on('error', (e) => {\n      print('res error', e)\n    })\n    let data = createServerData()\n    print('createServerData')\n\n    const stream = renderToPipeableStream(\n      <DataProvider data={data}>\n        <App assets={assets} />\n      </DataProvider>, {\n      onShellReady: () => {\n        stream.pipe(res)\n      },\n      onShellError: (e) => {\n        print('onShellError:', e)\n      }\n    }\n    );\n  }\n}).listen(8002, () => {\n  print('listen 8002...')\n})\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/rollup.config.js"},"rollup.config.js")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/package.json"},"package.json")," files are to build the React 18 SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the ",(0,r.kt)("inlineCode",{parentName:"p"},"npm")," command to build it.\nThe output is in the ",(0,r.kt)("inlineCode",{parentName:"p"},"dist/main.mjs")," file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install\nnpm run build\n")),(0,r.kt)("p",null,"Copy over the system's ",(0,r.kt)("inlineCode",{parentName:"p"},"modules")," to the working directory for Node.js API support as ",(0,r.kt)("a",{parentName:"p",href:"nodejs"},"noted here"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cp -r ../../modules .\n")),(0,r.kt)("p",null,"To run the example, do the following on the CLI to start the server."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"nohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &\n")),(0,r.kt)("p",null,"Send the server a HTTP request via ",(0,r.kt)("inlineCode",{parentName:"p"},"curl")," or the browser."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"curl http://localhost:8002\n")),(0,r.kt)("p",null,"The results are as follows. The service first returns an HTML page with an empty inner section (i.e., the ",(0,r.kt)("inlineCode",{parentName:"p"},"loading")," section), and then 2s later, the HTML content for the inner section and the JavaScript to display it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n100   439    0   439    0     0   1202      0 --:--:-- --:--:-- --:--:--  1199\n100  2556    0  2556    0     0   1150      0 --:--:--  0:00:02 --:--:--  1150\n100  2556    0  2556    0     0    926      0 --:--:--  0:00:02 --:--:--   926\n100  2806    0  2806    0     0    984      0 --:--:--  0:00:02 --:--:--   984\n<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport\n" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/m\nain.css"/><title>Hello</title></head><body><noscript><b>Enable JavaScript to run\n this app.</b></noscript>\x3c!--$--\x3e<main><nav><a href="/">Home</a></nav><aside cla\nss="sidebar">\x3c!--$?--\x3e<template id="B:0"></template><div class="spinner spinner-\n-active" role="progressbar" aria-busy="true"></div>\x3c!--/$--\x3e</aside><article cla\nss="post">\x3c!--$?--\x3e<template id="B:1"></template><div class="spinner spinner--ac\ntive" role="progressbar" aria-busy="true"></div>\x3c!--/$--\x3e<section class="comment\ns"><h2>Comments</h2>\x3c!--$?--\x3e<template id="B:2"></template><div class="spinner s\npinner--active" role="progressbar" aria-busy="true"></div>\x3c!--/$--\x3e</section><h2\n>Thanks for reading!</h2></article></main>\x3c!--/$--\x3e<script>assetManifest = {"mai\nn.js":"/main.js","main.css":"/main.css"};<\/script></body></html><div hidden id="\nS:0"><template id="P:3"></template></div><div hidden id="S:1"><template id="P:4"\n></template></div><div hidden id="S:2"><template id="P:5"></template></div><div \nhidden id="S:3"><h1>Archive</h1><ul><li>May 2021</li><li>April 2021</li><li>Marc\nh 2021</li><li>February 2021</li><li>January 2021</li><li>December 2020</li><li>\nNovember 2020</li><li>October 2020</li><li>September 2020</li></ul></div><script\n>function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for\n(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChil\nd,b);b.parentNode.removeChild(b)};$RS("S:3","P:3")<\/script><script>function $RC(\na,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.remo\nveChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{i\nf(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==\nd&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.\nfirstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRet\nry()}};$RC("B:0","S:0")<\/script><div hidden id="S:4"><h1>Hello world</h1><p>This\n demo is \x3c!-- --\x3e<b>artificially slowed down</b>. Open\x3c!-- --\x3e \x3c!-- --\x3e<code>ser\nver/delays.js</code> to adjust how much different things are slowed down.\x3c!-- --\n></p><p>Notice how HTML for comments &quot;streams in&quot; before the JS (or Re\nact) has loaded on the page.</p><p>Also notice that the JS for comments and side\nbar has been code-split, but HTML for it is still included in the server output.\n</p></div><script>$RS("S:4","P:4")<\/script><script>$RC("B:1","S:1")<\/script><div\n hidden id="S:5"><p class="comment">Wait, it doesn&#x27;t wait for React to load\n?</p><p class="comment">How does this even work?</p><p class="comment">I like ma\nrshmallows</p></div><script>$RS("S:5","P:5")<\/script><script>$RC("B:2","S:2")</s\ncript>\n')),(0,r.kt)("p",null,"The streaming SSR examples make use of WasmEdge's unique asynchronous networking capabilities and ES6 module support (i.e., the rollup bundled JS file contains ES6 modules). You can learn more about ",(0,r.kt)("a",{parentName:"p",href:"http_service/server"},"async networking")," and ",(0,r.kt)("a",{parentName:"p",href:"es6"},"ES6")," in this book."),(0,r.kt)("h2",{id:"appendix-the-create-react-app-template"},"Appendix the create-react-app template"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"create-react-app")," template is a popular starting point for many developers to create React apps. In this tutorial, we will provide a step-by-step guide on how to use it to create React streaming SSR applications that run on WasmEdge."),(0,r.kt)("h3",{id:"step-1--create-the-react-app"},"Step 1 \u2014 Create the React App"),(0,r.kt)("p",null,"First, use ",(0,r.kt)("inlineCode",{parentName:"p"},"npx")," to create a new React app. Let\u2019s name the app ",(0,r.kt)("inlineCode",{parentName:"p"},"react-ssr-example"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npx create-react-app react-ssr-example\n")),(0,r.kt)("p",null,"Then, ",(0,r.kt)("inlineCode",{parentName:"p"},"cd")," into the directory for the newly created app."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd react-ssr-example\n")),(0,r.kt)("p",null,"Start the new app in order to verify the installation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm start\n")),(0,r.kt)("p",null,"You should see the example React app displayed in your browser window. At this stage, the app is rendered in the browser. The browser runs the generated React JavaScript to build the HTML DOM UI."),(0,r.kt)("p",null,"Now in order to prepare for SSR, you will need to make some changes to the app's ",(0,r.kt)("inlineCode",{parentName:"p"},"index.js")," file. Change ReactDOM's ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," method to ",(0,r.kt)("inlineCode",{parentName:"p"},"hydrate")," to indicate to the DOM renderer that you intend to rehydrate the app after it is rendered on the server.\nReplace the contents of the ",(0,r.kt)("inlineCode",{parentName:"p"},"index.js")," file with the following."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nReactDOM.hydrate(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n")),(0,r.kt)("p",null,"Note: you should import ",(0,r.kt)("inlineCode",{parentName:"p"},"React")," redundantly in the ",(0,r.kt)("inlineCode",{parentName:"p"},"src/App.js"),", so the server will recognize it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import React from 'react';\n//...\n")),(0,r.kt)("p",null,"That concludes setting up the application, you can move on to setting up the server-side rendering functions."),(0,r.kt)("h3",{id:"step-2--create-an-wasmedge-quickjs-server-and-render-the-app-component"},"Step 2 \u2014 Create an WasmEdge QuickJS Server and Render the App Component"),(0,r.kt)("p",null,"Now that you have the app in place, let\u2019s set up a server that will render the HTML DOM by running the React JavaScript and then send the rendered elements to the browser. We will use WasmEdge as a secure, high-performance and lightweight container to run React JavaScript."),(0,r.kt)("p",null,"Create a new ",(0,r.kt)("inlineCode",{parentName:"p"},"server")," directory in the project's root directory."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"mkdir server\n")),(0,r.kt)("p",null,"Then, inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"server")," directory, create a new ",(0,r.kt)("inlineCode",{parentName:"p"},"index.js")," file with the server code."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import * as React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport * as std from 'std';\nimport * as http from 'wasi_http';\nimport * as net from 'wasi_net';\n\nimport App from '../src/App.js';\n\nasync function handle_client(cs) {\n  print('open:', cs.peer());\n  let buffer = new http.Buffer();\n\n  while (true) {\n    try {\n      let d = await cs.read();\n      if (d == undefined || d.byteLength <= 0) {\n        return;\n      }\n      buffer.append(d);\n      let req = buffer.parseRequest();\n      if (req instanceof http.WasiRequest) {\n        handle_req(cs, req);\n        break;\n      }\n    } catch (e) {\n      print(e);\n    }\n  }\n  print('end:', cs.peer());\n}\n\nfunction enlargeArray(oldArr, newLength) {\n  let newArr = new Uint8Array(newLength);\n  oldArr && newArr.set(oldArr, 0);\n  return newArr;\n}\n\nasync function handle_req(s, req) {\n  print('uri:', req.uri)\n\n  let resp = new http.WasiResponse();\n  let content = '';\n  if (req.uri == '/') {\n    const app = ReactDOMServer.renderToString(<App />);\n    content = std.loadFile('./build/index.html');\n    content = content.replace('<div id=\"root\"></div>', `<div id=\"root\">${app}</div>`);\n  } else {\n    let chunk = 1000; // Chunk size of each reading\n    let length = 0; // The whole length of the file\n    let byteArray = null; // File content as Uint8Array\n    \n    // Read file into byteArray by chunk\n    let file = std.open('./build' + req.uri, 'r');\n    while (true) {\n      byteArray = enlargeArray(byteArray, length + chunk);\n      let readLen = file.read(byteArray.buffer, length, chunk);\n      length += readLen;\n      if (readLen < chunk) {\n        break;\n      }\n    }\n    content = byteArray.slice(0, length).buffer;\n    file.close();\n  }\n  let contentType = 'text/html; charset=utf-8';\n  if (req.uri.endsWith('.css')) {\n    contentType = 'text/css; charset=utf-8';\n  } else if (req.uri.endsWith('.js')) {\n    contentType = 'text/javascript; charset=utf-8';\n  } else if (req.uri.endsWith('.json')) {\n    contentType = 'text/json; charset=utf-8';\n  } else if (req.uri.endsWith('.ico')) {\n    contentType = 'image/vnd.microsoft.icon';\n  } else if (req.uri.endsWith('.png')) {\n    contentType = 'image/png';\n  }\n  resp.headers = {\n    'Content-Type': contentType\n  };\n\n  let r = resp.encode(content);\n  s.write(r);\n}\n\nasync function server_start() {\n  print('listen 8002...');\n  try {\n    let s = new net.WasiTcpServer(8002);\n    for (var i = 0; ; i++) {\n      let cs = await s.accept();\n      handle_client(cs);\n    }\n  } catch (e) {\n    print(e);\n  }\n}\n\nserver_start();\n")),(0,r.kt)("p",null,"The server renders the ",(0,r.kt)("inlineCode",{parentName:"p"},"<App>")," component, and then sends the rendered HTML string back to the browser. Three important things are taking place here."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ReactDOMServer's ",(0,r.kt)("inlineCode",{parentName:"li"},"renderToString")," is used to render the ",(0,r.kt)("inlineCode",{parentName:"li"},"<App/>")," to an HTML string."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"index.html")," file from the app's ",(0,r.kt)("inlineCode",{parentName:"li"},"build")," output directory is loaded as a template. The app's content is injected into the ",(0,r.kt)("inlineCode",{parentName:"li"},"<div>")," element with an id of ",(0,r.kt)("inlineCode",{parentName:"li"},'"root"'),". It is then sent back as HTTP response."),(0,r.kt)("li",{parentName:"ul"},"Other files from the ",(0,r.kt)("inlineCode",{parentName:"li"},"build")," directory are read and served as needed at the requests of the browser.")),(0,r.kt)("h3",{id:"step-3--build-and-deploy"},"Step 3 \u2014 Build and deploy"),(0,r.kt)("p",null,"For the server code to work, you will need to bundle and transpile it. In this section, we will show you how to use webpack and Babel. In this next section, we will demonstrate an alternative (and potentially easier) approach using rollup.js."),(0,r.kt)("p",null,"Create a new Babel configuration file named ",(0,r.kt)("inlineCode",{parentName:"p"},".babelrc.json")," in the project's root directory and add the ",(0,r.kt)("inlineCode",{parentName:"p"},"env")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"react-app")," presets."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "presets": [\n    "@babel/preset-env",\n    "@babel/preset-react"\n  ]\n}\n')),(0,r.kt)("p",null,"Create a webpack config for the server that uses Babel Loader to transpile the code. Start by creating the ",(0,r.kt)("inlineCode",{parentName:"p"},"webpack.server.js")," file in the project's root directory."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const path = require(\'path\');\nmodule.exports = {\n  entry: \'./server/index.js\',\n  externals: [\n    {"wasi_http": "wasi_http"},\n    {"wasi_net": "wasi_net"},\n    {"std": "std"}\n  ],\n  output: {\n    path: path.resolve(\'server-build\'),\n    filename: \'index.js\',\n    chunkFormat: "module",\n    library: {\n      type: "module"\n    },\n  },\n  experiments: {\n    outputModule: true\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: \'babel-loader\'\n      },\n      {\n        test: /\\.css$/,\n        use: ["css-loader"]\n      },\n      {\n        test: /\\.svg$/,\n        use: ["svg-url-loader"]\n      }\n    ]\n  }\n};\n')),(0,r.kt)("p",null,"With this configuration, the transpiled server bundle will be output to the ",(0,r.kt)("inlineCode",{parentName:"p"},"server-build")," folder in a file called ",(0,r.kt)("inlineCode",{parentName:"p"},"index.js"),"."),(0,r.kt)("p",null,"Next, add the ",(0,r.kt)("inlineCode",{parentName:"p"},"svg-url-loader")," package by entering the following commands in your terminal."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install svg-url-loader --save-dev\n")),(0,r.kt)("p",null,"This completes the dependency installation and webpack and Babel configuration."),(0,r.kt)("p",null,"Now, revisit ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json")," and add helper npm scripts. Add ",(0,r.kt)("inlineCode",{parentName:"p"},"dev:build-server"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"dev:start-server")," scripts to the ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json")," file to build and serve the SSR application."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"scripts": {\n  "dev:build-server": "NODE_ENV=development webpack --config webpack.server.js --mode=development",\n  "dev:start-server": "wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js",\n  // ...\n},\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"dev:build-server")," script sets the environment to ",(0,r.kt)("inlineCode",{parentName:"li"},'"development"')," and invokes webpack with the configuration file you created earlier."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"dev:start-server")," script runs the WasmEdge server from the ",(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge")," CLI tool to serve the built output. The ",(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge_quickjs.wasm")," program contains the QuickJS runtime. ",(0,r.kt)("a",{parentName:"li",href:"hello_world"},"Learn more"))),(0,r.kt)("p",null,"Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start up the server on ",(0,r.kt)("inlineCode",{parentName:"p"},":8002"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm run build\nnpm run dev:build-server\nnpm run dev:start-server\n")),(0,r.kt)("p",null,"Open ",(0,r.kt)("inlineCode",{parentName:"p"},"http://localhost:8002/")," in your web browser and observe your server-side rendered app."),(0,r.kt)("p",null,"Previously, the HTML source in the browser is simply the template with SSR placeholders."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'Output\n<div id="root"></div>\n')),(0,r.kt)("p",null,"Now, with the SSR function running on the server, the HTML source in the browser is as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'Output\n<div id="root"><div class="App" data-reactroot="">...</div></div>\n')),(0,r.kt)("h3",{id:"step-4-alternative----build-and-deploy-with-rollupjs"},"Step 4 (alternative) -- build and deploy with rollup.js"),(0,r.kt)("p",null,"Alternatively, you could use the ",(0,r.kt)("a",{parentName:"p",href:"https://rollupjs.org/guide/en/"},"rollup.js")," tool to ",(0,r.kt)("a",{parentName:"p",href:"npm"},"package all application components and library modules")," into a single file for WasmEdge to execute."),(0,r.kt)("p",null,"Create a rollup config for the server that uses Babel Loader to transpile the code. Start by creating the ",(0,r.kt)("inlineCode",{parentName:"p"},"rollup.config.js")," file in the project's root directory."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const {babel} = require('@rollup/plugin-babel');\nconst nodeResolve = require('@rollup/plugin-node-resolve');\nconst commonjs = require('@rollup/plugin-commonjs');\nconst replace = require('@rollup/plugin-replace');\n\nconst globals = require('rollup-plugin-node-globals');\nconst builtins = require('rollup-plugin-node-builtins');\nconst plugin_async = require('rollup-plugin-async');\nconst css = require(\"rollup-plugin-import-css\");\nconst svg = require('rollup-plugin-svg');\n\nconst babelOptions = {\n  babelrc: false,\n  presets: [\n    '@babel/preset-react'\n  ],\n  babelHelpers: 'bundled'\n};\n\nmodule.exports = [\n  {\n    input: './server/index.js',\n    output: {\n      file: 'server-build/index.js',\n      format: 'esm',\n    },\n    external: [ 'std', 'wasi_net','wasi_http'],\n    plugins: [\n      plugin_async(),\n      babel(babelOptions),\n      nodeResolve({preferBuiltins: true}),\n      commonjs({ignoreDynamicRequires: false}),\n      css(),\n      svg({base64: true}),\n      globals(),\n      builtins(),\n      replace({\n        preventAssignment: true,  \n        'process.env.NODE_ENV': JSON.stringify('production'),\n        'process.env.NODE_DEBUG': JSON.stringify(''),\n      }),\n    ],\n  },\n];\n")),(0,r.kt)("p",null,"With this configuration, the transpiled server bundle will be output to the ",(0,r.kt)("inlineCode",{parentName:"p"},"server-build")," folder in a file called ",(0,r.kt)("inlineCode",{parentName:"p"},"index.js"),"."),(0,r.kt)("p",null,"Next, add the dependent packages to the ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json")," then install with ",(0,r.kt)("inlineCode",{parentName:"p"},"npm"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'  "devDependencies": {\n    //...\n    "@rollup/plugin-babel": "^5.3.0",\n    "@rollup/plugin-commonjs": "^21.0.1",\n    "@rollup/plugin-node-resolve": "^7.1.3",\n    "@rollup/plugin-replace": "^3.0.0",\n    "rollup": "^2.60.1",\n    "rollup-plugin-async": "^1.2.0",\n    "rollup-plugin-import-css": "^3.0.3",\n    "rollup-plugin-node-builtins": "^2.1.2",\n    "rollup-plugin-node-globals": "^1.4.0",\n    "rollup-plugin-svg": "^2.0.0"\n  }\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install\n")),(0,r.kt)("p",null,"This completes the dependency installation and rollup configuration."),(0,r.kt)("p",null,"Now, revisit ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json")," and add helper npm scripts. Add ",(0,r.kt)("inlineCode",{parentName:"p"},"dev:build-server"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"dev:start-server")," scripts to the ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json")," file to build and serve the SSR application."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"scripts": {\n  "dev:build-server": "rollup -c rollup.config.js",\n  "dev:start-server": "wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js",\n  // ...\n},\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"dev:build-server")," script sets the environment to ",(0,r.kt)("inlineCode",{parentName:"li"},'"development"')," and invokes webpack with the configuration file you created earlier."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"dev:start-server")," script runs the WasmEdge server from the ",(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge")," CLI tool to serve the built output. The ",(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge_quickjs.wasm")," program contains the QuickJS runtime. ",(0,r.kt)("a",{parentName:"li",href:"hello_world"},"Learn more"))),(0,r.kt)("p",null,"Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start up the server on ",(0,r.kt)("inlineCode",{parentName:"p"},":8002"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm run build\nnpm run dev:build-server\nnpm run dev:start-server\n")),(0,r.kt)("p",null,"Open ",(0,r.kt)("inlineCode",{parentName:"p"},"http://localhost:8002/")," in your web browser and observe your server-side rendered app."),(0,r.kt)("p",null,"Previously, the HTML source in the browser is simply the template with SSR placeholders."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'Output\n<div id="root"></div>\n')),(0,r.kt)("p",null,"Now, with the SSR function running on the server, the HTML source in the browser is as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'Output\n<div id="root"><div class="App" data-reactroot="">...</div></div>\n')))}c.isMDXComponent=!0}}]);